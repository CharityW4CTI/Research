import sys
import pefile
import yara
from idautils import *
from idc import *
from idaapi import *
import sark
import idautils, idc, idaapi


def getVA(filename, offset):
    pe = pefile.PE(filename)
    try:
        return pe.get_rva_from_offset(offset) + pe.OPTIONAL_HEADER.ImageBase
    except TypeError:
        print("Couldn't Mmap offset %s to RVA" % (offset))
        return None


def yaraSearch(filename, rules):
    results = {}

    matches = rules.match(filename)
    for rule in matches:
        for s in rule.strings:
            offset, var, match = s
            if getVA(filename, offset) != None:
                try:
                    results[rule][match].append(getVA(filename, offset))
                except KeyError:
                    results[rule] = {match: [getVA(filename, offset)]}
    return results


def findAndColor(offset):
    success = False
    for ref in XrefsTo(offset, 0):
        f = get_func(ref.frm)
        try:
            f_start = f.startEA
            code_block = sark.CodeBlock(ref.frm)
            code_block.color = 0x00ffff00
            set_color(f_start, CIC_FUNC, 0x0055fff)
            success = True
        except AttributeError:
            success = False
    return success


def append_comment(ea, s, repeatable=True):
    '''
    add the given string as a (possibly repeating) comment to the given address.
    does not add the comment if it already exists.
    adds the comment on its own line.
    Args:
      ea (int): the address at which to add the comment.
      s (str): the comment text.
      repeatable (bool): if True, set a repeatable comment.
    Raises:
      UnicodeEncodeError: if the given string is not ascii.
    '''
    # see: http://blogs.norman.com/2011/security-research/improving-ida-analysis-of-x64-exception-handling

    s = s.encode('ascii')

    if repeatable:
        string = idc.RptCmt(ea)
    else:
        string = idc.Comment(ea)

    if not string:
        string = s  # no existing comment
    else:
        if s in string:  # ignore duplicates
            return
        string = string + '\n' + s

    if repeatable:
        idc.MakeRptCmt(ea, string)
    else:
        idc.MakeComm(ea, string)


def prompt_for_file_path(title="Select a file to open"):
    class MyForm(idaapi.Form):
        def __init__(self):
            self.invert = False
            idaapi.Form.__init__(self, r"""{title:s}
<#{title:s}#{title:s}:{{iFileOpen}}>
""".format(title=title), {'iFileOpen': idaapi.Form.FileInput(open=True), })

        def OnFormChange(self, fid):
            return 1

    f = MyForm()
    f.Compile()
    f.iFileOpen.value = ""
    ok = f.Execute()
    if ok == 1:
        ret = f.iFileOpen.value
        f.Free()
        return ret
    f.Free()
    return None


yararules = prompt_for_file_path(title='Select YARA rule file')
filename = prompt_for_file_path(title='Select original file (executable)')

rules = yara.compile(filepath=yararules)
results = yaraSearch(filename, rules)

offsets = []

s = Strings()

for ss in s:
    offsets.append({"start": int(ss.ea), "end": (int(ss.ea) + ss.length)})

for ruleName, matches in results.items():
    for k, v in matches.items():
        v = list(set(v))
        for offset in v:
            c = "Matches %s" % (ruleName)
            append_comment(offset, c)
            for range in offsets:
                if offset < range["end"] and offset > range["start"]:
                    offset = range["start"]
                    success = findAndColor(offset)
                    if success == False:
                        print("\"%s\" was found at offset %s, but could not be highlighted" % (k, hex(offset)))
                elif offset == range["start"]:
                    success = findAndColor(offset)
                    if success == False:
                        print("\"%s\" was found at offset %s, but could not be highlighted" % (k, hex(offset)))
